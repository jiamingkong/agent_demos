from mcp.server.fastmcp import FastMCP
from pathlib import Path
import subprocess
import os
import ast
import re
from typing import Optional, List, Dict

# Initialize FastMCP server
mcp = FastMCP("coder", log_level="ERROR")

def _analyze_python_file(path: Path) -> str:
    """Extracts high-level structure (classes, functions, docstrings) from a Python file."""
    try:
        content = path.read_text(encoding='utf-8', errors='replace')
        tree = ast.parse(content)
        summary = []
        
        # Module Docstring
        docstring = ast.get_docstring(tree)
        if docstring:
            summary.append(f"Docstring: \"\"\"{docstring.strip().splitlines()[0]}...\"\"\"")

        for node in tree.body:
            if isinstance(node, ast.ClassDef):
                methods = [n.name for n in node.body if isinstance(n, ast.FunctionDef)]
                summary.append(f"Class: {node.name} ({', '.join(methods)})")
            elif isinstance(node, ast.FunctionDef):
                summary.append(f"Function: {node.name}")
            elif isinstance(node, ast.Assign):
                # Try to catch uppercase constants
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id.isupper():
                        summary.append(f"Constant: {target.id}")
        
        return "\n".join(summary)
    except Exception as e:
        return f"Error parsing Python file: {e}"

@mcp.tool()
def investigate_and_save_report(folder_path: str) -> str:
    """
    Investigates a folder structure to create a comprehensive context report for LLM agents.
    Scans structure, reads key configuration/dependency files, and existing documentation.
    Saves the report to '.test.Agent.md'.
    
    Args:
        folder_path: The absolute path of the folder to investigate.
    """
    import datetime
    
    p = Path(folder_path).expanduser().resolve()
    if not p.exists() or not p.is_dir():
        return f"Error: {folder_path} is not a valid directory."

    report_path = p / ".test.Agent.md"
    
    # Configuration for exploration
    IGNORE_DIRS = {'.git', '__pycache__', 'node_modules', 'venv', '.env', 'dist', 'build', '.idea', '.vscode', 'target'}
    IGNORE_FILES = {'.DS_Store', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', '.test.Agent.md'}
    
    # Generate Tree Structure
    structure_lines = []
    python_analyses = []
    other_files_summary = []

    for root, dirs, files in os.walk(str(p)):
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        
        rel_path = os.path.relpath(root, str(p))
        if rel_path == ".":
            level = 0
            prefix = ""
        else:
            level = rel_path.count(os.sep) + 1
            prefix = rel_path + "/"
            
        indent = "  " * level
        structure_lines.append(f"{indent}{os.path.basename(root)}/")
        
        subindent = "  " * (level + 1)
        for f in sorted(files):
            if f in IGNORE_FILES: continue
            structure_lines.append(f"{subindent}{f}")
            
            file_path = Path(root) / f
            file_rel_path = prefix + f
            
            # Analyze Python Files
            if f.endswith('.py'):
                analysis = _analyze_python_file(file_path)
                if analysis:
                    python_analyses.append(f"- **{file_rel_path}**\n```text\n{analysis}\n```")
            
            # Summarize Config/Readmes (Keep it short)
            elif f.upper().startswith('README') or f in ['requirements.txt', 'package.json', 'Dockerfile']:
                try:
                    content = file_path.read_text(encoding='utf-8', errors='replace')
                    preview = content[:500].strip() + ("..." if len(content) > 500 else "")
                    other_files_summary.append(f"- **{file_rel_path}**\n```text\n{preview}\n```")
                except: pass

    # Construct the report
    report_content = [
        f"# Project Context Report: {p.name}",
        f"Generated: {datetime.datetime.now().isoformat()}",
        "",
        "## 1. Project Structure",
        "```text",
    ]
    report_content.extend(structure_lines)
    report_content.append("```")
    report_content.append("")
    report_content.append("## 2. Python Code High-Level Overview")
    report_content.append("Generated by parsing AST. Shows classes, methods, and docstrings.")
    report_content.extend(python_analyses)
    report_content.append("")
    report_content.append("## 3. Configuration & Documentation (Preview)")
    report_content.extend(other_files_summary)
    
    final_report = "\n".join(report_content)
    
    try:
        report_path.write_text(final_report, encoding='utf-8')
        return f"Investigation complete. Context report saved to {report_path}."
    except Exception as e:
        return f"Error investigating folder: {str(e)}"

@mcp.tool()
def read_code_file(file_path: str, start_line: int = 1, end_line: int = -1) -> str:
    """
    Read a code file, optionally reading specific lines.
    
    Args:
        file_path: Absolute path to the file.
        start_line: Starting line number (1-based, inclusive).
        end_line: Ending line number (1-based, inclusive). Set to -1 for end of file.
    """
    try:
        p = Path(file_path).expanduser().resolve()
        if not p.exists(): return f"Error: File not found at {file_path}"
        if not p.is_file(): return f"Error: Path is not a file: {file_path}"
        
        with open(p, 'r', encoding='utf-8', errors='replace') as f:
            lines = f.readlines()
            
        total_lines = len(lines)
        if start_line < 1: start_line = 1
        if end_line == -1 or end_line > total_lines: end_line = total_lines
        
        if start_line > total_lines:
            return "File has fewer lines than start_line."
            
        selected_lines = lines[start_line-1:end_line]
        
        content = "".join(selected_lines)
        return f"--- {file_path} (Lines {start_line}-{end_line} of {total_lines}) ---\n{content}"
    except Exception as e:
        return f"Error reading file: {str(e)}"

@mcp.tool()
def search_in_files(folder_path: str, pattern: str) -> str:
    """
    Search for a pattern in files within a folder using grep.
    
    Args:
        folder_path: The directory to search in.
        pattern: The text or regex pattern to search for.
    """
    try:
        p = Path(folder_path).expanduser().resolve()
        if not p.exists(): return f"Error: Path not found: {folder_path}"
        
        # Using grep -r
        result = subprocess.run(
            ['grep', '-r', '-n', pattern, str(p)],
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0 and result.returncode != 1:
            return f"Grep command failed: {result.stderr}"
            
        if not result.stdout:
            return "No matches found."
            
        # Truncate if too long
        output = result.stdout
        if len(output) > 5000:
            output = output[:5000] + "\n... (output truncated)"
            
        return output
    except Exception as e:
        return f"Error executing search: {str(e)}"

@mcp.tool()
def edit_code_file(file_path: str, old_string: str, new_string: str) -> str:
    """
    Edit a file by replacing an exact string with a new string.
    
    Args:
        file_path: Absolute path to the file.
        old_string: The exact string to find and replace.
        new_string: The string to replace it with.
    """
    try:
        p = Path(file_path).expanduser().resolve()
        if not p.exists(): return f"Error: File not found: {file_path}"
        
        content = p.read_text(encoding='utf-8')
        
        if old_string not in content:
            return "Error: old_string not found in file. Please ensure exact match including whitespace."
        
        # Check if multiple occurrences
        if content.count(old_string) > 1:
             return "Error: old_string matches multiple locations. Please Provide more context in old_string to make it unique."
             
        new_content = content.replace(old_string, new_string)
        p.write_text(new_content, encoding='utf-8')
        
        return "File updated successfully."
    except Exception as e:
        return f"Error editing file: {str(e)}"

@mcp.tool()
def apply_edit_blocks(file_path: str, edits: str) -> str:
    """
    Apply multiple search/replace edits to a file using the following format:
    
    <<<<<<< SEARCH
    (original code to replace)
    =======
    (new code)
    >>>>>>> REPLACE
    
    Args:
        file_path: Absolute path to the file.
        edits: A string containing one or more edit blocks.
    """
    try:
        p = Path(file_path).expanduser().resolve()
        if not p.exists(): return f"Error: File not found: {file_path}"
        
        content = p.read_text(encoding='utf-8')
        
        # Regex to find blocks. We assume markers are on their own lines.
        # Captures content between markers.
        pattern = re.compile(
            r'<<<<<<< SEARCH\n(.*?)=======\n(.*?)>>>>>>> REPLACE',
            re.DOTALL
        )
        
        changes = pattern.findall(edits)
        if not changes:
            return "Error: No valid SEARCH/REPLACE blocks found. Ensure you use the exact format:\n<<<<<<< SEARCH\n...\n=======\n...\n>>>>>>> REPLACE"
            
        new_content = content
        
        for i, (search_block, replace_block) in enumerate(changes, 1):
            if search_block not in new_content:
                return f"Error applying Edit #{i}: SEARCH block not found in file. Ensure exact match including indentation and whitespace."
            
            if new_content.count(search_block) > 1:
                return f"Error applying Edit #{i}: SEARCH block matches multiple locations (count: {new_content.count(search_block)}). Include more context."
                
            new_content = new_content.replace(search_block, replace_block, 1)
            
        p.write_text(new_content, encoding='utf-8')
        return f"Successfully applied {len(changes)} edits to {p.name}."
        
    except Exception as e:
        return f"Error applying edits: {str(e)}"

@mcp.tool()
def run_terminal_command(command: str) -> str:
    """
    Run a terminal command. 
    Warning: This allows execution of arbitrary shell commands. 
    
    Args:
        command: The command execution string.
    """
    # Note: User confirmation is typically handled by the client/UI invoking this tool.
    # The agent should be cautious.
    try:
        result = subprocess.run(
            command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=60 # Default timeout
        )
        
        output = f"COMMAND: {command}\n\nSTDOUT:\n{result.stdout}\nSTDERR:\n{result.stderr}"
        return output
    except subprocess.TimeoutExpired:
        return f"Error: Command '{command}' timed out."
    except Exception as e:
        return f"Error running command: {str(e)}"

@mcp.tool()
def create_file(file_path: str, content: Optional[str] = None, overwrite: bool = True, append: bool = False) -> str:
    """
    Create a new file with optional content, overwrite existing file, or append.
    
    Args:
        file_path: Absolute path to the file.
        content: Optional text content to write. If None, creates an empty file.
        overwrite: If True (default), overwrite existing file; if False, raise error when file exists.
        append: If True, append content to existing file (creates file if doesn't exist).
                When append is True, overwrite is ignored.
    
    Returns:
        Success message or error description.
    """
    try:
        p = Path(file_path).expanduser().resolve()
        
        if p.exists() and not overwrite and not append:
            return f"Error: File already exists at {file_path} and overwrite is False."
        
        mode = 'a' if append else 'w'
        encoding = 'utf-8'
        
        # Ensure parent directories exist
        p.parent.mkdir(parents=True, exist_ok=True)
        
        with open(p, mode, encoding=encoding) as f:
            if content is not None:
                f.write(content)
        
        action = "Appended to" if append else "Created" if not p.exists() else "Overwritten"
        return f"Success: {action} file at {p}"
    except Exception as e:
        return f"Error creating file: {str(e)}"

if __name__ == "__main__":
    mcp.run()
